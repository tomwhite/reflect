<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Reflect</title>
    <script
      defer
      data-domain="tom-e-white.com"
      src="https://plausible.io/js/script.js"
    ></script>
    <script>
      window.plausible =
        window.plausible ||
        function () {
          (window.plausible.q = window.plausible.q || []).push(arguments);
        };
    </script>
    <script src="//cdn.jsdelivr.net/npm/phaser@3.55.2/dist/phaser.min.js"></script>
    <style type="text/css">
      body {
        margin: 0;
      }
    </style>
    <link
      rel="apple-touch-icon"
      sizes="180x180"
      href="favicon/apple-touch-icon.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="32x32"
      href="favicon/favicon-32x32.png"
    />
    <link
      rel="icon"
      type="image/png"
      sizes="16x16"
      href="favicon/favicon-16x16.png"
    />
    <link rel="manifest" href="favicon/site.webmanifest" />
  </head>
  <body>
    <script type="text/javascript">
      // Scale sprites so we can have a high resolution for other graphics (text, lines)
      const SCALE = 2;

      const SCREEN_WIDTH = 240 * SCALE;
      const SCREEN_HEIGHT = 400 * SCALE;

      const BLOCK_SIZE = 40 * SCALE;
      const CELL_SIZE = 38 * SCALE;

      const BEAM_WIDTH = 5 * SCALE;
      const GRID_WIDTH = 1 * SCALE;

      const SPRITE_NAMES = {
        "/": "oblique_mirror",
        "\\": "reverse_oblique_mirror",
        o: "mirror_ball",
      };

      // https://sashamaps.net/docs/resources/20-colors/
      const COLOURS = [
        "#e6194B",
        "#3cb44b",
        "#ffe119",
        "#4363d8",
        "#f58231",
        "#42d4f4",
        "#f032e6",
        "#fabed4",
        "#469990",
        "#dcbeff",
        "#9A6324",
        "#fffac8",
        "#800000",
        "#aaffc3",
        "#000075",
        "#a9a9a9",
      ].map((hex) => Phaser.Display.Color.HexStringToColor(hex).color);

      const TEXT_STYLE_10_PT = {
        fontFamily: "Arial",
        fontSize: 10 * SCALE,
        color: "black",
        padding: {
          bottom: 2,
        },
      };

      const TEXT_STYLE_24_PT = {
        fontFamily: "Arial",
        fontSize: 24 * SCALE,
        color: "black",
        padding: {
          bottom: 2,
        },
      };

      function blockIndexToCoord(i, j, y_offset = BLOCK_SIZE) {
        const x = i * BLOCK_SIZE + BLOCK_SIZE / 2;
        const y = j * BLOCK_SIZE + BLOCK_SIZE / 2;
        return [x, y + y_offset];
      }

      class Board {
        constructor(text) {
          this.fullBoard = text
            .split("\n")
            .filter((line) => line.trim().length > 0 && !line.startsWith("#"))
            .map((line) => line.split(""));
          this.n = this.fullBoard.length - 2;
          this.hiddenBlocks = this.fullBoard
            .slice(1, this.n + 1)
            .map((arr) => arr.slice(1, this.n + 1));
        }

        get pieces() {
          return this.hiddenBlocks
            .flat()
            .filter((piece) => piece != ".")
            .sort();
        }

        // Return all the edge locations in a predictable order.
        *edgeLocations() {
          for (let x = 1; x <= this.n; x++) {
            yield [x, 0];
          }
          for (let y = 1; y <= this.n; y++) {
            yield [0, y];
          }
          for (let x = 1; x <= this.n; x++) {
            yield [x, this.n + 1];
          }
          for (let y = 1; y <= this.n; y++) {
            yield [this.n + 1, y];
          }
        }

        // Return all the beam names ("A", "B", etc) in sorted order
        get beamNames() {
          return [...this.edgeLocations()]
            .map((loc) => this.fullBoard[loc[1]][loc[0]])
            .filter((piece) => piece != ".")
            .sort()
            .filter((value, index, array) => array.indexOf(value) === index); // unique
        }

        getPath(x, y) {
          const n1 = this.n + 1;
          const path = [];
          path.push([x, y]);
          let dx = 0;
          let dy = 0;
          if (x == 0) {
            dx = 1;
            dy = 0;
          } else if (x == n1) {
            dx = -1;
            dy = 0;
          } else if (y == 0) {
            dx = 0;
            dy = 1;
          } else if (y == n1) {
            dx = 0;
            dy = -1;
          }
          x += dx;
          y += dy;
          path.push([x, y]);
          while (true) {
            if ([0, n1].includes(x) || [0, n1].includes(y)) {
              // TODO: check end point has same path label
              break;
            }
            const val = this.fullBoard[y][x];
            if (val == "/") {
              [dx, dy] = [-dy, -dx];
            } else if (val == "\\") {
              [dx, dy] = [dy, dx];
            } else if (val == "o") {
              [dx, dy] = [-dx, -dy];
            }
            x += dx;
            y += dy;
            path.push([x, y]);
          }
          return path;
        }
        get beamPaths() {
          const paths = [];
          for (let beamName of this.beamNames) {
            let startLoc = null;
            for (let loc of this.edgeLocations()) {
              if (this.fullBoard[loc[1]][loc[0]] == beamName) {
                startLoc = loc;
                const path = this.getPath(loc[0], loc[1]);
                paths.push(path);
                break;
              }
            }
          }
          return paths;
        }
      }

      // Format a date in ISO format (YYYY-MM-DD) according to local time
      // From https://stackoverflow.com/a/50130338
      function formatDate(date) {
        return new Date(date.getTime() - date.getTimezoneOffset() * 60000)
          .toISOString()
          .split("T")[0];
      }

      const today = formatDate(new Date());

      function saveEvent(name) {
        const eventHistoryJson = localStorage.getItem("eventHistory");
        const eventHistory =
          eventHistoryJson == null ? [] : JSON.parse(eventHistoryJson);
        const event = {
          puzzle: today,
          name: name,
          timestamp: Date.now(),
        };
        eventHistory.push(event);
        localStorage.setItem("eventHistory", JSON.stringify(eventHistory));
      }

      function savePlayed() {
        const solvedHistoryJson = localStorage.getItem("solvedHistory");
        const solvedHistory =
          solvedHistoryJson == null
            ? []
            : Array.from(new Set(JSON.parse(solvedHistoryJson))).sort();
        const playedHistoryJson = localStorage.getItem("playedHistory");
        const playedHistory =
          playedHistoryJson == null
            ? solvedHistory // init from solved history
            : Array.from(new Set(JSON.parse(playedHistoryJson))).sort();
        if (!playedHistory.includes(today)) {
          playedHistory.push(today);
          localStorage.setItem("playedHistory", JSON.stringify(playedHistory));
        }
      }

      function saveSolved() {
        const solvedHistoryJson = localStorage.getItem("solvedHistory");
        const solvedHistory =
          solvedHistoryJson == null
            ? []
            : Array.from(new Set(JSON.parse(solvedHistoryJson))).sort();
        if (!solvedHistory.includes(today)) {
          solvedHistory.push(today);
          localStorage.setItem("solvedHistory", JSON.stringify(solvedHistory));
        }
      }

      function getStats() {
        const solvedHistoryJson = localStorage.getItem("solvedHistory");
        const solvedHistory =
          solvedHistoryJson == null
            ? []
            : Array.from(new Set(JSON.parse(solvedHistoryJson))).sort();
        const solved = Array.from(new Set(solvedHistory)).length;
        console.log(`Solved: ${solved}`);

        let currentStreak = 0;
        Array.from(new Set(solvedHistory))
          .sort()
          .reverse()
          .map((d) => new Date(d))
          .forEach((d, i) => {
            if (new Date(today) - d === i * 60 * 60 * 24 * 1000) {
              currentStreak++;
            }
          });
        console.log(`Streak: ${currentStreak}`);
        return { solved: solved, currentStreak: currentStreak };
      }

      class PlayScene extends Phaser.Scene {
        constructor() {
          super({ key: "PlayScene" });
        }

        preload() {
          this.load.image("logo", "sprites/reflect.png");
          for (const name of Object.values(SPRITE_NAMES)) {
            this.load.image(name, `sprites/${name}_tr.png`);
          }
          this.load.image("help", "sprites/help.png");
          this.load.text("puzzle", `puzzles/puzzle-${today}.txt`);
          savePlayed(); // assume played if loaded today's puzzle
          plausible("preload");
          saveEvent("preload");
        }

        create() {
          const puzzle = this.cache.text.get("puzzle");
          const board = new Board(puzzle);
          const n = board.n;
          const hiddenBlocks = board.hiddenBlocks;
          const beamPaths = board.beamPaths;
          const pieces = board.pieces;
          const boardValues = Array.from(Array(n), () => Array(n).fill("."));
          const board_y_offset = BLOCK_SIZE;

          let gameOver = false;
          let seenFirstMove = false;

          // Logo
          const logo = this.add.image(SCREEN_WIDTH / 2, BLOCK_SIZE / 2, "logo");
          logo.setScale(SCALE);

          // Beams
          const beamGraphics = this.add.graphics();
          for (var bi = 0; bi < beamPaths.length; bi++) {
            const beamPath = beamPaths[bi];
            const start = beamPath[0];
            const end = beamPath[beamPath.length - 1];
            for (let [i, j] of [start, end]) {
              beamGraphics.lineStyle(BEAM_WIDTH, COLOURS[bi]);
              const [x, y] = blockIndexToCoord(i, j);
              if (i == 0) {
                beamGraphics.lineBetween(BEAM_WIDTH, y, BLOCK_SIZE, y);
              } else if (i == n + 1) {
                beamGraphics.lineBetween(
                  BLOCK_SIZE * (n + 1),
                  y,
                  BLOCK_SIZE * (n + 2) - BEAM_WIDTH,
                  y
                );
              } else if (j == 0) {
                beamGraphics.lineBetween(
                  x,
                  BEAM_WIDTH + board_y_offset,
                  x,
                  BLOCK_SIZE + board_y_offset
                );
              } else if (j == n + 1) {
                beamGraphics.lineBetween(
                  x,
                  BLOCK_SIZE * (n + 1) + board_y_offset,
                  x,
                  BLOCK_SIZE * (n + 2) - BEAM_WIDTH + board_y_offset
                );
              }
            }
          }

          // Board lines
          const boardGraphics = this.add.graphics();
          boardGraphics.lineStyle(GRID_WIDTH, "black");

          for (var x = BLOCK_SIZE; x < BLOCK_SIZE * (n + 2); x += BLOCK_SIZE) {
            boardGraphics.lineBetween(
              x,
              BLOCK_SIZE + board_y_offset,
              x,
              BLOCK_SIZE * (n + 1) + board_y_offset
            );
          }
          for (var y = BLOCK_SIZE; y < BLOCK_SIZE * (n + 2); y += BLOCK_SIZE) {
            boardGraphics.lineBetween(
              BLOCK_SIZE,
              y + board_y_offset,
              BLOCK_SIZE * (n + 1),
              y + board_y_offset
            );
          }

          // Beam paths
          const beamPathGraphics = this.add.graphics();
          beamPathGraphics.visible = false;
          for (var bi = 0; bi < beamPaths.length; bi++) {
            const beamPath = beamPaths[bi];
            for (var bj = 0; bj < beamPath.length - 1; bj++) {
              const start = beamPath[bj];
              const end = beamPath[bj + 1];
              const [x0, y0] = blockIndexToCoord(start[0], start[1]);
              const [x1, y1] = blockIndexToCoord(end[0], end[1]);

              beamPathGraphics.lineStyle(BEAM_WIDTH, COLOURS[bi]);
              beamPathGraphics.lineBetween(x0, y0, x1, y1);
            }
          }

          // Cells
          const cellGraphics = this.add.graphics();
          cellGraphics.fillStyle(0xf0f8ff);

          for (var i = 0; i < n; i++) {
            for (var j = 0; j < n; j++) {
              const [x, y] = blockIndexToCoord(i + 1, j + 1);
              const zone = this.add
                .zone(x, y, CELL_SIZE, CELL_SIZE)
                .setRectangleDropZone(CELL_SIZE, CELL_SIZE)
                .setData("loc", [i, j]);

              cellGraphics.fillRect(
                zone.x - zone.input.hitArea.width / 2,
                zone.y - zone.input.hitArea.height / 2,
                zone.input.hitArea.width,
                zone.input.hitArea.height
              );
            }
          }

          for (var i = 0; i < pieces.length; i++) {
            let [x, y] = blockIndexToCoord(
              (i % 4) + 1,
              Math.floor(i / 4),
              BLOCK_SIZE * (n + 2) + board_y_offset
            );

            const zone = this.add
              .zone(x, y, CELL_SIZE, CELL_SIZE)
              .setRectangleDropZone(CELL_SIZE, CELL_SIZE);

            cellGraphics.fillRect(
              zone.x - zone.input.hitArea.width / 2,
              zone.y - zone.input.hitArea.height / 2,
              zone.input.hitArea.width,
              zone.input.hitArea.height
            );
          }

          // Blocks
          for (var i = 0; i < pieces.length; i++) {
            let [x, y] = blockIndexToCoord(
              (i % 4) + 1,
              Math.floor(i / 4),
              BLOCK_SIZE * (n + 2) + board_y_offset
            );

            const image = this.add
              .image(x, y, SPRITE_NAMES[pieces[i]])
              .setInteractive();
            image.setScale(SCALE);
            image.setData("piece", pieces[i]);
            this.input.setDraggable(image);
          }

          [x, y] = blockIndexToCoord(5, 0);
          const help = this.add.image(x, y, "help").setInteractive();
          help.setScale(SCALE);
          help.on("pointerup", (e) => {
            this.scene.setVisible(false, "PlayScene");
            this.scene.launch("HelpScene");
            this.scene.pause();
          });

          this.input.on("drag", function (pointer, gameObject, dragX, dragY) {
            // update image coordinates as it is dragged
            gameObject.x = dragX;
            gameObject.y = dragY;
          });

          this.input.on("dragleave", function (pointer, gameObject, dropZone) {
            // remove image from drop zone
            if (dropZone.data && dropZone.data.get("image") === gameObject) {
              dropZone.data.remove("image");
            }
          });

          this.input.on(
            "drop",
            function (pointer, gameObject, dropZone) {
              if (dropZone.data && dropZone.data.get("image") !== undefined) {
                // drop zone already occupied - reset position
                gameObject.x = gameObject.input.dragStartX;
                gameObject.y = gameObject.input.dragStartY;
                return;
              }

              gameObject.x = dropZone.x;
              gameObject.y = dropZone.y;
              dropZone.setData("image", gameObject);
              if (dropZone.data.get("loc") !== undefined) {
                // drop zone is on board
                if (gameObject.data.get("loc") !== undefined) {
                  // remove piece from board
                  const [i, j] = gameObject.data.get("loc");
                  boardValues[j][i] = ".";
                  gameObject.data.remove("loc");
                }
                // add piece to the board
                const [i, j] = dropZone.data.get("loc");
                gameObject.setData("loc", [i, j]);
                boardValues[j][i] = gameObject.data.get("piece");

                // test if game over
                if (
                  JSON.stringify(boardValues) == JSON.stringify(hiddenBlocks)
                ) {
                  cellGraphics.visible = false;
                  beamPathGraphics.visible = true;
                  gameOver = true;
                  // disable dragging
                  let images = this.children.list.filter(
                    (x) => x instanceof Phaser.GameObjects.Image
                  );
                  images.forEach((image) =>
                    image.input ? this.input.setDraggable(image, false) : null
                  );
                  // save to local storage
                  saveSolved();
                  const stats = getStats();
                  this.add
                    .text(
                      BLOCK_SIZE * 1.5,
                      BLOCK_SIZE * (n + 2) + BLOCK_SIZE / 2 + board_y_offset,
                      stats.solved,
                      TEXT_STYLE_24_PT
                    )
                    .setOrigin(0.5);
                  this.add
                    .text(
                      BLOCK_SIZE * 1.5,
                      BLOCK_SIZE * (n + 2) + BLOCK_SIZE + board_y_offset,
                      "Solved",
                      TEXT_STYLE_10_PT
                    )
                    .setOrigin(0.5, 0);
                  this.add
                    .text(
                      BLOCK_SIZE * 3,
                      BLOCK_SIZE * (n + 2) + BLOCK_SIZE / 2 + board_y_offset,
                      stats.currentStreak,
                      TEXT_STYLE_24_PT
                    )
                    .setOrigin(0.5);
                  this.add
                    .text(
                      BLOCK_SIZE * 3,
                      BLOCK_SIZE * (n + 2) + BLOCK_SIZE + board_y_offset,
                      "Current",
                      TEXT_STYLE_10_PT
                    )
                    .setOrigin(0.5, 0);
                  this.add
                    .text(
                      BLOCK_SIZE * 3,
                      BLOCK_SIZE * (n + 2) + BLOCK_SIZE * 1.3 + board_y_offset,
                      "Streak",
                      TEXT_STYLE_10_PT
                    )
                    .setOrigin(0.5, 0);
                  plausible("solved");
                  saveEvent("solved");
                }
              } else if (gameObject.data.get("loc") !== undefined) {
                // drop zone is not on board, but piece was previously on board
                // remove piece from board
                const [i, j] = gameObject.data.get("loc");
                boardValues[j][i] = ".";
                gameObject.data.remove("loc");
              }
            },
            this
          );

          this.input.on("dragend", function (pointer, gameObject, dropped) {
            if (!dropped) {
              // not dropped on drop zone - reset position
              gameObject.x = gameObject.input.dragStartX;
              gameObject.y = gameObject.input.dragStartY;
            }
            if (!seenFirstMove) {
              saveEvent("firstMove");
              seenFirstMove = true;
            }
          });
        }
      }

      class HelpScene extends Phaser.Scene {
        constructor() {
          super({ key: "HelpScene" });
        }

        preload() {
          this.load.text("helpPuzzle", `puzzles/puzzle-help.txt`);
        }

        create() {
          const puzzle = this.cache.text.get("helpPuzzle");
          const board = new Board(puzzle);
          const n = board.n;
          const hiddenBlocks = board.hiddenBlocks;
          const beamPaths = board.beamPaths;
          const pieces = board.pieces;
          const board_y_offset = BLOCK_SIZE * 2;

          // Logo
          const logo = this.add.image(SCREEN_WIDTH / 2, BLOCK_SIZE / 2, "logo");
          logo.setScale(SCALE);

          // Beams
          const beamGraphics = this.add.graphics();
          for (var bi = 0; bi < beamPaths.length; bi++) {
            const beamPath = beamPaths[bi];
            const start = beamPath[0];
            const end = beamPath[beamPath.length - 1];
            for (let [i, j] of [start, end]) {
              beamGraphics.lineStyle(BEAM_WIDTH, COLOURS[bi]);
              const [x, y] = blockIndexToCoord(i, j, board_y_offset);
              if (i == 0) {
                beamGraphics.lineBetween(BEAM_WIDTH, y, BLOCK_SIZE, y);
              } else if (i == n + 1) {
                beamGraphics.lineBetween(
                  BLOCK_SIZE * (n + 1),
                  y,
                  BLOCK_SIZE * (n + 2) - BEAM_WIDTH,
                  y
                );
              } else if (j == 0) {
                beamGraphics.lineBetween(
                  x,
                  BEAM_WIDTH + board_y_offset,
                  x,
                  BLOCK_SIZE + board_y_offset
                );
              } else if (j == n + 1) {
                beamGraphics.lineBetween(
                  x,
                  BLOCK_SIZE * (n + 1) + board_y_offset,
                  x,
                  BLOCK_SIZE * (n + 2) - BEAM_WIDTH + board_y_offset
                );
              }
            }
          }

          // Board lines
          const boardGraphics = this.add.graphics();
          boardGraphics.lineStyle(GRID_WIDTH, "black");

          for (var x = BLOCK_SIZE; x < BLOCK_SIZE * (n + 2); x += BLOCK_SIZE) {
            boardGraphics.lineBetween(
              x,
              BLOCK_SIZE + board_y_offset,
              x,
              BLOCK_SIZE * (n + 1) + board_y_offset
            );
          }
          for (var y = BLOCK_SIZE; y < BLOCK_SIZE * (n + 2); y += BLOCK_SIZE) {
            boardGraphics.lineBetween(
              BLOCK_SIZE,
              y + board_y_offset,
              BLOCK_SIZE * (n + 1),
              y + board_y_offset
            );
          }

          // Beam paths
          const beamPathGraphics = this.add.graphics();
          for (var bi = 0; bi < beamPaths.length; bi++) {
            const beamPath = beamPaths[bi];
            for (var bj = 0; bj < beamPath.length - 1; bj++) {
              const start = beamPath[bj];
              const end = beamPath[bj + 1];
              const [x0, y0] = blockIndexToCoord(
                start[0],
                start[1],
                board_y_offset
              );
              const [x1, y1] = blockIndexToCoord(
                end[0],
                end[1],
                board_y_offset
              );

              beamPathGraphics.lineStyle(BEAM_WIDTH, COLOURS[bi]);
              beamPathGraphics.lineBetween(x0, y0, x1, y1);
            }
          }

          // Blocks
          const [x0, y0] = blockIndexToCoord(3, 3, board_y_offset);
          this.add.image(x0, y0, SPRITE_NAMES["/"]).setScale(SCALE);
          const [x1, y1] = blockIndexToCoord(4, 3, board_y_offset);
          this.add.image(x1, y1, SPRITE_NAMES["\\"]).setScale(SCALE);
          const [x2, y2] = blockIndexToCoord(4, 1, board_y_offset);
          this.add.image(x2, y2, SPRITE_NAMES["o"]).setScale(SCALE);

          // Help text
          this.add.text(
            0,
            BLOCK_SIZE * 1.25,
            "Drag the mirrors onto the grid, so that",
            TEXT_STYLE_10_PT
          );
          this.add.text(
            0,
            BLOCK_SIZE * 1.625,
            "each beam of light connects to the same colour",
            TEXT_STYLE_10_PT
          );
          this.add.text(
            0,
            BLOCK_SIZE * 2.375,
            "For example:",
            TEXT_STYLE_10_PT
          );
          let y_offset = BLOCK_SIZE * (n + 2) + board_y_offset;
          this.add.text(
            0,
            y_offset,
            "A new puzzle is released every day",
            TEXT_STYLE_10_PT
          );
          y_offset += BLOCK_SIZE * 0.375;
          this.add.text(
            0,
            y_offset,
            "Â© 2023 Tom White (tom.e.white@gmail.com)",
            TEXT_STYLE_10_PT
          );

          this.input.on("pointerup", (e) => {
            this.scene.resume("PlayScene");
            this.scene.stop();
            this.scene.setVisible(true, "PlayScene");
          });
        }
      }

      const config = {
        type: Phaser.AUTO,
        width: SCREEN_WIDTH,
        height: SCREEN_HEIGHT,
        scale: {
          mode: Phaser.Scale.FIT,
          autoCenter: Phaser.Scale.CENTER_BOTH,
        },
        backgroundColor: "#FFFFFF",
        scene: [PlayScene, HelpScene],
      };

      const game = new Phaser.Game(config);
    </script>
  </body>
</html>
